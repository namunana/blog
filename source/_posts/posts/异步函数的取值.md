---
title: 异步函数的取值
url: async_url
tags:
  - 小程序
categories:
  - 小程序
data: 2020-10-04 10:30:00
---
# 异步函数的取值

## 异步函数的处理
因为异步函数不能像同步函数那样，将返回值赋值给一个变量，所以我们要想取到异步函数的返回值，必须要对其进行相应的处理。
<!--more-->
## 处理异步函数的方式
_这里讲的异步函数主要是wx.request，其他异步函数类同与wx.request，不再做过多阐述，异步函数的处理有三种方式，分别是callback回调函数、promise、async和await.但是我只推荐大家使用async和await，其他两种只做简单的介绍。_
#### callback回调函数
这里所指的回调函数和JS中的回调函数大体是一样的，我们知道wx.request()里面有个success属性，它是一个函数类型，其中res作为参数就是函数返回的结果，这时我们就可以传递一个函数过去接收到返回结果。通过一段代码来演示吧。
  将wx.request()请求封装在Http类里面，重点看15-17行代码
```javascript
import {config} from "../config.js"
class Http{
  request(params){
    if(!params.method){
      params.method="GET"
    }
    wx.request({
      url: config.api_base_url+params.url,
      data: params.data,
      method: params.method,
      header:{
        'content-type':'application/json',
        'appkey':config.appkey
      },
      success: (res) => {
         params.yu(res)
      },
      fail: (err) => {}
    })
  }
  
}
export{
  Http
}
```

这时在page页面下的js文件中的初始化函数里，这里直接调用Http类，将url和一个函数传递进去，然后在wx.request()中success里面调用该函数，把res作为参数传递进去，就可以取得请求返回的结果了。
```javascript
  onLoad: function (options) {
    http.request({
      url:'classic/latest',
      yu:(res)=>{
        console.log(res)
      }
    })
```

通过回调函数取得结果确实是个不错的选择，但是当seccuss里面又调用wx.request(),而该wx.request()里的success里又用wx.request()，这种情况下就形成了回调地狱，这样代码可读性会非常的差，而且使用回调函数处理异步函数剥夺了函数return的能力（如果函数每嵌套一层，就要多传递一个callback），这就是我不推荐大家使用callback回调函数的原因
#### promise
promise相对于callback来说优势体现在以下三个方面：

+ 代码风格，首先它解决了回调地狱的问题，而且它不会剥夺函数return的能力

+ 它可以使多个异步等待合并

+ 不需要层层传递callback，其实也就是它没剥夺函数return的能力。
 
>_试想为什么promise可以解决callback回调地狱和剥夺return的能力的问题？_
 
个人的理解是promise是一个对象,而不是一个函数，因为对象可以保存数据的状态，而函数不可以（当然先排除闭包函数）
 
说了这么多，promise该怎么使用呢？只需要三步就可以实现：

1. new Promise(),传递一个函数，函数里有两个参数分别是resolve和reject

```javascript
 const promise = new Promise((resolve,reject)=>{
      
    })
```
 
2. 将异步代码放入该函数
 
```javascript
 const promise = new Promise((resolve,reject)=>{
      wx.getSystemInfo({
        //pending fulfilled rejected 
        success: (res) => {
          resolve(res)
        },
        fail:(error)=>{
          reject(error)
        }
      })
    })
```
 
因为promise是一个对象，可以保存状态，所以promise它有三种状态：pending(进行中)、fulfilled(已完成)、rejected(已失败)，当promise被创建时起，就处于进行中，通过resolve可以将状态变成已完成，通过reject可以将进行中变成已失败。但是一旦修改了promise的状态，状态就会凝固，不能再被修改。依此可以知道，resolve(res)可以获取成功后的数据，reject(error)获取失败后的数据。

3. 通过then方法，传递两个回调函数

```javascript
promise.then(
      (res)=>{
        console.log(res)
      },
      (error)=>{
        console.log(error)
      }
    )
```

通过第二步就可以知道，(res)是打印成功后的信息的，(error)打印的是失败后的信息的。

**注意:then方法的两个回调函数位置不可以互换，已完成必须在已失败前面，当然你也可以只传递任意一个回调函数。**

#### async和await

其实async和await是基于promise的，要想学会用async和await,必须要先会promise。async和await就目前来说，可以说是异步请求的最终解决方案了。它相比于promise来说，可读性要强一点，这也是我推荐大家使用中方法的原因。

简单说一下async和await
async：强制保证一个函数必须返回promise
await：等待异步函数返回结果

async和await的适用场景：必须要用在有返回值的API前面，当然这里指的返回值主要是promise对象，在不使用云服务的项目里，大部分的API是不能直接返回promise的，只能通过回调函数来获取返回值。但是这并不能阻挡我们使用async和await,我们可以通过一个函数来实现转置，使其支持promise，我们可以看以下段代码。

```javascript
const promisic = function (func){
  return function(params = {}){
    return new Promise((resolve,reject)=>{
      const args = Object.assign(params,{
        success:(res)=>{
          resolve(res);
        },
        fail:(error)=>{
          reject(error);
        }
      });
      func(args);
    })
  }
}
export{
  promisic
}
```

我们只需要将异步函数作为参数传进去就可以使其支持promise了，通过以上代码你会发现，它其实就是要求你返回一个promise的对象，这有点类似于代理模式，将一个异步函数丢进去，内部的细节就不用去管了。

那么async和await该怎么使用呢？举个栗子演示一下
```javascript
import {config} from "../config/config";
import {promisic} from "./util";
class Http {
  static async request({url, data, method = "GET"}) {
   const res = await promisic(wx.request)({
      url: `${config.apiBaseUrl}${url}`,
      data,
      header: {
        appkey: config.appkey
      },
      method: 'GET'
    })
    return res.data
  }
}
export{
  Http
}
```
在第五行我们将wx.request作为参数传进去了，然后前面要加上await，而对于这个方法（函数）也必须要加上async
而对于函数的调用方来说,加不加async和await要看具体情况
```javascript
import{Http} from "../utils/http"
class Activity{
  static locationD = 'a-2'
  static async getHomeLocationD(){
    return await Http.request({
      url:`activity/name/${Activity.locationD}`
    })
  }
}

export{
  Activity
}
```
比如说像以上代码,我虽然调用了Http的request()方法，但是，这个request方法后面不需要对返回的结果做任何操作，所以不需要等待结果的返回，即也可以不需要用await,而request()的返回结果本身就是一个promise,所以它所在的方法也不用加async，但是对于初学者来说，如果你分不清什么时候要加async和await，那就直接在每个调用方都加上，不影响结果的返回。
```javascript

import {Activity} from "../../model/activity"

Page({

  /**
   * 页面的初始数据
   */
  data: {
    activityD:null,
  },

  /**
   * 生命周期函数--监听页面加载
   */
  async onLoad(options) {
    this.initAllData()
  },

  async initAllData(){
    const activityD = await Activity.getHomeLocationD();
    this.setData({
      activityD,  
    })

  },
```
而在page页面下，这里就需要加async和await了，因为后面要做数据绑定，就必须等待数据的返回，而且要强制保证返回的必须是promise。
> _以上就是处理异步函数的三种方法，我强烈推荐大家使用async和await。具体原因通过我前面的介绍就可晓而知。_

