---
title: 瀑布流的实现（上）：分页数据的处理
url: flow_url
tags:
 - 小程序
categories:
 - 小程序
---
# 瀑布流的实现（上）：分页数据的处理
_为了更好的让大家理解瀑布流，所以用两篇文章给大家讲解，此外，如果读者想要读懂本篇博客，需要有一点点小程序基础_
<!--more-->
## 一、思路
> 什么是瀑布流？

+ 刚提到这个名词时，大家兴许会有些陌生，但是大家对淘宝、京东或许可能就不为陌生了。大家可能都有过不断刷新淘宝首页的经历
* 接下来我用两张图直观的给大家介绍一下什么是瀑布流!

{% img /images/write/flow/taobao.PNG %}

通过上面两张图片我们可以看出，商品的排列横向是没有对齐的，而是形成了一种错落有格的排列方式，像这种布局，我们就叫做 __瀑布流__，又称 __瀑布流式布局__

* 大家在逛淘宝是会发现，我们不断向上滑动时，这些产品列表才会显示（渲染）给我们，而不是一口气将数据一次性加载完。那么它是怎样将数据批量的发送给用户的呢？

_答案是分页，移动端的小伙伴或许有些惊讶，因为严格意义上来说，page一般只出现在PC端，对于移动端是没有这种分页这个概念的，为了满足瀑布流式布局，前端开发者必须对分页的数据进行处理_

> 如何处理分页数据？

关于如何处理分页数据，具体的思路我通过思维导图来展示

{% img /images/write/flow/page.PNG %}

  + 页面首先要考虑两点，一是一条数据都没有，二是最后一页，没有更多数据了
  + 其次是数据的累加，也就是页面的重新渲染，举个栗子，假如我们有100条数据，star(从第几条开始加载)=0，count(一次能加载数量)=10，那么我们在第一次setData的时候是加载1-10条，那么到了第二次setData的时候就要加载1-20条数据，第三次就要加载1-30条数据，依次类推...
  + 如果在非分页的情况下有两种情况：一是正在加载、二是空，没有数据
  + 如果是分页数据有三种情况：一是正在加载、二是加载完成、三是没有更多数据
  + 此外，我们还要考虑防抖和截流，简单的说就是当用户不停的向上滑动的时候，我们要避免用户重复发送请求而导致数据错乱，常见的防护方法有Button的禁用、数据锁、交互提示loading，还有后端的Redis缓存，而这里我们用locker数据锁来防范。

## 二、具体实现
> _首先我们要探讨一下怎样获得这个数据，然后再进行处理，可能你们的第一反应会是：“很简单啊，直接wx.request({})获取不就行了吗？”，这当然可取，但是当一个小程序有多个地方都要用到瀑布流布局时，直接wx.request是繁琐、可读性差的，所以我们会想到封装_

_那么怎么样来实现这个封装，在ES5的语法里我们可以用函数，但是我更推荐大家用ES6语法中的类，因为类可以保存数据的状态，直接把处理细节封装在类里面_

_让我们来看一下API清单，看一下返回的数据是怎样的？__
```java
{
    "total":17,//数据总条数
    "count":10,//一次能返回最大的数据条数
    "page":0,//当前页码
    "total_page":2,//总页数
    "items":[
        {
            "id":27,
            "title":"Mier双色靠椅",
            "subtitle":"安静的午后，一杯清茶，追忆似水年华。看清风浮动，看落日余晖",
            "img":"http://i2.sleeve.7yue.pro/h1.png",
            "for_theme_img":"http://i1.sleeve.7yue.pro/assets/f6c9fce8-626f-44c0-a709-3f6ef9f3fbef.png",
            "price":"1299",
            "discount_price":null,
            "description":null,
            "tags":"",
            "sketch_spec_id":"1",
            "max_purchase_quantity":null,
            "min_purchase_quantity":null
        }
    ]
    }
```

+ 我们定义一个Paging的类
首先我们的实现思路是在类里面发送请求，获取数据后在类里面进行处理，而对于调用者来说不需要在意细节，只要我创建了类的实例，调用了类对外开放的方法，就可以获得数据，至于里面的细节调用者是不在乎的
```javascript
class Paging {
    start //从第几条开始取
    count //每一次取多少条
    locker = false
    //初始化构造器:用来初始化参数
    constructor(count = 10, start = 0) {
        this.start = start
        this.count = count
    }

    //获得数据
    async getMoreData() {
        //1.判断有没有上数据锁，如果有锁则直接返回
        if(!this._getLocker()){
            return
        }
        //2.加载数据
        
        //3.释放数据锁
        this._releaseLocker()
        //4.返回数据
        return data
    }
    //数据锁：有上锁（locker=true）直接返回，
    //  没有上锁（locker=false），先上锁，后返回true
    _getLocker() {
        if (this.locker) {
            return false
        }
        this.locker = true
        return true
    }
   //数据锁的解锁
    _releaseLocker() {
        this.locker = false
    }
```
实现思路我之前已经分析过了，以上代码中，getMoreData()就是对外开放让调用者获取数据的方法，我们只需要做四个步骤即可：

1. 用数据锁，判断当前请求有没有完成，如果未完成(locker=true)，则直接返回，如果请求完成了（locker=false），先上锁，以防用户重复发送请求，然后再做后面的步骤（locker来控制锁，false表示未上锁，true表示已上锁）

2. 发送请求，获得数据，将数据返回给调用者

3. 当上一步执行完成后就直接释放数据锁

4. 最后返回数据

> 重点

1. 我们把开头和结尾的细节实现了，接下来就是分页处理的核心操作部分，就是上述的步骤二，如果有认真看我之前的分页数据处理的分析的话，接下来的的步骤你们可能会豁然开朗。
```javascript
import {Http} from "./http";

class Paging {

    start
    count
    req
    locker = false
    url

    //初始化构造器
    constructor(req, count = 10, start = 0) {
        this.start = start
        this.count = count
        this.req = req
        this.url = req.url
    }
//获得数据
    async getMoreData() {
        if(!this.moreData){
            return
        }
        //判断有没有上数据锁，如果有锁则直接返回
        if(!this._getLocker()){
            return
        }
        //加载数据
        const data =await this._actualGetData()
        //释放数据锁
        this._releaseLocker()
        //返回数据
        return data
    }


    async _actualGetData() {
        const req = this._getCurrentReq()
        let paging = await Http.request(req)
        //非分页数据：a正在加载、b空
        //分页数据：a正在加载、b加载完成、c没有更多数据、
        //通过返回一个对象，把数据返回回去
        //return {
        //  empty:Boolean 判断是否为空
        //  items:Array  保存数据
        //  moreData:Booleam 判断有没有更多数
        //  accumlator:Array 累加器
        // }
        if(!paging){
            return null
        }
        if(paging.total === 0){
            return {
                empty:true, //判断是否为空
                items:[], //保存数据
                moreData:false, //判断有没有更多数据
                accumulator:[] //累加器
            }
        }

    }

    //获得当前请求对象
    _getCurrentReq() {
        let url = this.url
        const params = `start=${this.start}&count=${this.count}`
        if(url.includes('?')){
            url += '&' + params
            // contains
        }
        else{
            url += '?' + params
        }
        this.req.url  = url
        return this.req
    }
```
2. 我们不可能把数据的调用和处理都放在getMoreData()方法里，这样可读性会很差，所以我们定义了一个私有方法_actualGetData(),在这里面发送请求并对数据进行处理。


3. 在此之前我们要获得请求对象，简单来说就是获取url，所以我们定义了一个req属性，而在私有方法_getCurrentReq()中我们要对url是否带参进行判断：一种情况是（带参）：v1/by/spu?name=abc...另一种是（不带参）：v1/by/spu。（这里只是举例说明），然后将处理的req对象返回回去

4. 将请求对象放入Http.request()中，获得分页数据，数据也有了，就差分页数据处理了，这里我们要将处理后的请求用json对象返回，还是像之前对非分页和分页的分析一样，这里也要对多种情况进行处理：

+ 首先判断有没有获取到数据，没获取到则直接返回。

+ 其次是如果获取到0条数据，也要根据情况返回数据。

```javascript
async _actualGetData() {
        const req = this._getCurrentReq()
        let paging = await Http.request(req)
        //非分页数据：a正在加载、b空
        //分页数据：a正在加载、b加载完成、c没有更多数据、
        //通过返回一个对象，把数据返回回去
        //return {
        //  empty:Boolean 判断是否为空
        //  items:Array  保存数据
        //  moreData:Booleam 判断有没有更多数
        //  accumlator:Array 累加器
        // }
        
        if(!paging){
            return null
        }
        if(paging.total === 0){
            return {
                empty:true,
                items:[],
                moreData:false,
                accumulator:[]
            }
        }

        this.moreData = Paging._moreData(paging.total_page, paging.page)
        //数据的累加处理
        if(this.moreData){
            this.start += this.count
        }
        this._accumulate(paging.items)
        return {
            empty:false,
            items: paging.items,
            moreData:this.moreData,
            accumulator:this.accumulator
        }
    }
    //数据的累积：concat()数组合并
    _accumulate(items){
        this.accumulator = this.accumulator.concat(items)
    }
    //判断是否有更多数据
    static _moreData(totalPage, pageNum) {
        return pageNum < totalPage-1
    }
```
5. 之前我们分析了数据没有获取到和数据为空两种情况，接下来就是有数据，如果获取到了数据那么又该怎么处理呢？

+ 要判断是否是最后一页，如果当前页码大于总的页数-1（页码从0开始的），则就获取不到数据了。

+ 要对数据进行累加处理，所以定义一个数据的累加器accmulator，对数据进行合并。

_到目前为止。我们就完成了Paging类的分装，当外部需要获取数据时直接调用该类即可，关于Http类的封装，还有如何调用Paging类留到下一章讲解。这一章把重点和难点的准备工作都做好了，后面的调用问题就不大了，下章见！_




  
  
  
  
  









